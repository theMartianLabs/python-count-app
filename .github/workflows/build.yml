name: Build and Deploy Docker Image

on:
  push:
    branches:
      - develop-app

jobs:
  build-and-push:
    name: Build Docker image and push to ECR using OIDC
    runs-on: ubuntu-latest
    permissions:
      id-token: write       # Required for OIDC
      contents: write      # Required for release creation
    outputs:
      next_version_tag: ${{ steps.next_version.outputs.tag }}  # Propagate tag to deploy job
      repo_name: ${{ steps.repo-name.outputs.repo_name }}      # Propagate repo name

    steps:
    - name: Check out the repo
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Necessary to fetch all tags and history

    - name: Configure AWS credentials using OIDC
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: ${{ secrets.AWS_REGION }}
        role-session-name: GitHubActions

    - name: SonarQube Scan
      uses: SonarSource/sonarqube-scan-action@v3
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      with:
        args: >
          -Dsonar.projectKey=${{ secrets.SONAR_PROJECT_KEY }}
          -Dsonar.organization=${{ secrets.SONAR_ORGANIZATION }}
          -Dsonar.qualitygate.wait=true  # Fail build if quality gate fails

    - name: Determine Next Version
      id: next_version
      run: |
        # Fetch all tags
        git fetch --tags
        
        # Get the latest tag, assume semver, and sort
        LATEST_TAG=$(git tag -l | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | sort -V | tail -n1)
        
        # If there's no tag yet, start with v0.0.0
        if [ -z "$LATEST_TAG" ]; then
          LATEST_TAG="v0.0.0"
        fi
        
        # Increment the patch version
        NEXT_TAG=$(echo "$LATEST_TAG" | awk -F. '{print $1"."$2"."$3+1}')
        
        # Output the next version
        echo "tag=$NEXT_TAG" >> $GITHUB_OUTPUT
        echo "Next version: $NEXT_TAG"

    - name: Create Release
      id: create_release
      env:
        GH_TOKEN: ${{ github.token }}
      run: |
        # Create the release using GitHub API
        RESPONSE=$(curl -s -X POST \
          -H "Accept: application/vnd.github+json" \
          -H "Authorization: Bearer $GH_TOKEN" \
          https://api.github.com/repos/${{ github.repository }}/releases \
          -d "{\"tag_name\": \"${{ steps.next_version.outputs.tag }}\", \"name\": \"Release ${{ steps.next_version.outputs.tag }}\", \"draft\": false, \"prerelease\": false}")
        RELEASE_ID=$(echo "$RESPONSE" | jq -r '.id')
        if [ "$RELEASE_ID" = "null" ]; then
          echo "Failed to create release"
          exit 1
        fi
        echo "release_id=$RELEASE_ID" >> $GITHUB_OUTPUT
        echo "Release created with ID: $RELEASE_ID"

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Extract repository name
      id: repo-name
      run: |
        REPO_NAME="${GITHUB_REPOSITORY##*/}"
        echo "repo_name=$REPO_NAME" >> $GITHUB_OUTPUT
        echo "REPO_NAME=$REPO_NAME" >> $GITHUB_ENV

    - name: Build and Push Docker image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: ${{ steps.repo-name.outputs.repo_name }}
        IMAGE_TAG: ${{ steps.next_version.outputs.tag }}
      run: |
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        echo "IMAGE_NAME=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_ENV

    - name: Run Snyk to check Docker image for vulnerabilities
      uses: snyk/actions/docker@master
      env:
        SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
      with:
        image: ${{ env.IMAGE_NAME }}
        args: --severity-threshold=high --policy-path=.snyk

  deploy:
    name: Deploy Docker image to EC2
    runs-on: ubuntu-latest
    needs: build-and-push
    permissions:
      id-token: write
      contents: read

    steps:
    - name: Configure AWS credentials using OIDC
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: ${{ secrets.AWS_REGION }}
        role-session-name: GitHubActionsDeploy

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Deploy to EC2
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: ${{ needs.build-and-push.outputs.repo_name }}
        IMAGE_TAG: ${{ needs.build-and-push.outputs.next_version_tag }}
      run: |
        # Validate SSH key
        if [ -z "${{ secrets.EC2_SSH_KEY }}" ]; then
          echo "EC2_SSH_KEY is not set"
          exit 1
        fi
        
        # Write SSH key to file
        echo "${{ secrets.EC2_SSH_KEY }}" > ssh_key.pem
        chmod 600 ssh_key.pem
        
        # SSH into EC2 and deploy the Docker image
        ssh -o StrictHostKeyChecking=no -i ssh_key.pem ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF'
          # Ensure AWS CLI is installed
          if ! command -v aws >/dev/null 2>&1; then
            echo "AWS CLI not found, installing..."
            sudo apt-get update
            sudo apt-get install -y awscli
          fi
          
          # Ensure Docker is installed
          if ! command -v docker >/dev/null 2>&1; then
            echo "Docker not found, installing..."
            sudo apt-get update
            sudo apt-get install -y docker.io
            sudo systemctl start docker
            sudo systemctl enable docker
          fi
          
          # Log in to ECR
          aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | docker login --username AWS --password-stdin $ECR_REGISTRY
          
          # Pull the Docker image
          docker pull $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          
          # Stop and remove any existing container
          docker stop python-count-app || true
          docker rm python-count-app || true
          
          # Run the new container
          docker run -d --name python-count-app \
            -p 8080:8080 \
            $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          
          # Clean up unused images
          docker image prune -f
        EOF
        
        # Clean up SSH key
        rm -f ssh_key.pem
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_USER: ${{ secrets.EC2_USER }}
        EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}